#include  <iostream>    //для использования потоков ввода/вывода
//#include  <intrin.h> //для NOP
using namespace std;
#include <typeinfo.h>

int nTwin=1;      //глобальная переменная
namespace TwinSpace{ int nTwin=2;}  //переменная объявлена в цикле - TwinSpace

int main()
{

 //**********************************************************
  //Задание 1. Работа с отладчиком. Базовые типы данных. Выполняя программу по шагам, 
  //следите за значениями переменных и интерпретируйте результат (помните, что 
  //количество байт, отводимых под int, системо-зависимо).
  //Обратите внимание на разную интерпретацию отладчиком signed и unsigned целых типов 
  //данных, а также на внутреннее представление отрицательных целых чисел.

  
  char cByte = 'A'; // Задает значение 'А', ASCII 65
  cByte    = 0x42; // Задает значение шестнадцатеричным числом, код ASCII 66 
  cByte    = 66; // ASCII
  cByte    = -1; // На заданное значение не существует символа.  

  unsigned char ucByte = 0x41; // Задает значение шестнадцатеричным числом, код ASCII 65
  ucByte   = 'B'; // Символ 'B'
  ucByte   =  -1; // Невозможно присвоить отрицательное значение, -1 меняется на 255 и присваевается значение по ASCII

  int iInt =  0xffffffff; // Выше предела доступных чисел. Задаётся -1

  unsigned int uiInt = 0xffffffff; // 4294967295

  float fFloat = 1.f;  // 1 с типом float
  double dDouble = 1.; // 1 с типом double

  // Выполните фрагмент, приведенный далее. В комментариях отразите,
  // что реально заносится в переменную. Объясните разницу между этим 
  // значением и инициализатором.

  double d = 0.1234567890123456789123456789; // 0.12345678901234568, т.к предел цифр после запятой - 15-17. Значение округлили
  float  f = 0.1234567890123456789123456789; // 0.123456791, т.к предел цифр после запятой - 6-9. Значение округлили

  d  =  1.; // Заносится 1, потому что после запятой ничего нету
  d  =  0.999999999999999999999999999999999; // Задаёт 1, т.к превышен предел цифр после запятой. Округление

  
  // В комментариях напишите результат, возвращаемый оператором sizeof для
  // переменной типа wchar_t (ее размер)
  wchar_t cw = L'Ф';
  size_t n = sizeof(cw); // 2 байта


// **************************************************************
  //Задание 2a. Неявное приведение типов данных.
  //Объясните разницу результата при выполнении (1) и (2):
  //Покажите явно (напишите в коде) преобразования, которые неявно выполняет компилятор

  iInt=1;
  double dDouble1=iInt/3;    // (1) В результате 0
  // double dDouble2 = static_cast<double>(iInt / 3.);
  // Int - целое число, поэтому при делении этого числа на такое же целое получается число с типом Int. Значение округлилось
  double dDouble2=iInt/3.;  // (2) В результате 0.33333333333333331
  // double dDouble2 = static_cast<double>(iInt) / 3.;
  // Делитель с типом double. Результат так же получился с типом double.


  // Ассоциативность операторов.
  // Синтаксис языка C допускает "цепочечное" присваивание
  // (как в строках (1) и (2)). Посмотрев результаты выполнения строк (1) и (2)
  // (значения переменных dDouble, fFloat, nInt, sShort, cByte), определите порядок 
  // выполения присваиваний при цепочечной записи и объясните результат.
  // Расставте скобки, явно определяющие порядок выполнения, как это сделал бы компилятор.
  // Объясните (в комментариях) предупреждения (warnings) компилятора.
  short sShort;
  (dDouble=(fFloat=(iInt=(sShort=(cByte=(3.3/3))))));      // (1)
  // warning C4244 : '=' : conversion from 'double' to 'char', possible loss of data
  // При изменении типа double на char возможна потеря данных из-за их разницы в занимаемой памяти.
  // warning C4244: '=' : conversion from 'int' to 'float', possible loss of data
  // У Int больший обьем занимаемой памяти, чем у float.
  // компиллятор предупреждает о возможной потере данных
  
  (cByte=(sShort=(iInt=(fFloat=(dDouble=(3.3/3))))));      // (2)
  // warning C4244: '=' : conversion from 'double' to 'float', possible loss of data
  // double занимает 8 байт, float - 4. Возмодная потеря данных
  // warning C4244: '=' : conversion from 'float' to 'int', possible loss of data
  // При наличии цирф после запятой, теряется часть информации.
  // warning C4244: '=' : conversion from 'short' to 'char', possible loss of data
  // short - 2 байта, char - 1 байт, возможна потеря данных

  //ниже Вам дан пример "небрежного" использования неявного приведения типов, что может 
  // привести к нежелательным результатам - объясните (в комментариях), к каким?
  // Напишите явно преобразования, которые неявно выполняет компилятор

  iInt  =  257;
  cByte  =  iInt; // Значение 257 заходит за пределы диапазона чисел, доступных для типа данных char,
  // от числа 000100000001 убирается часть и остается 00000001

  unsigned char cN1=255, cN2=2, cSum;
  cSum = cN1 + cN2; // Максимальное значение для unsigned char - 255, а сумма равна 257
  // в двоичном формате это 000100000001, 
  // от числа 000100000001 убирается часть и остается 00000001

  //Сравните предыдущую строчку с приведенной ниже. Объясните (в комментариях),
  //почему в следующей строке не происходит выход за разрядную сетку
  // Напишите явно преобразования, которые неявно выполняет компилятор
  int iSum = cN1+cN2; // В итоге получается значение с типом int

  //Напишите, почему при сложении одинаковых значений (одинаковых в двоичной системе) 
  // в строках (1) и (2) получаются разные результаты
  // Напишите явно преобразования, которые неявно выполняет компилятор и объясните,
  // что при этом происходит
  char c1=0xff, c2=2;
  unsigned char uc1=0xff, uc2=2;
  int iSum1= c1 + c2;   //(1) c1 = -1 и c2 = 2, -1 + 2 = 1
  int iSum2= uc1 + uc2; //(2) uc1 = 255, 255 + 2 = 257


  
// ***********************************************************
  //Задание 2b. Явное приведение типов данных.
  //Проинтерпретируйте результат (значения переменной dDouble) в строке (3)
  // Напишите явно преобразования, которые неявно выполняет компилятор
  int nTmp=100, nn=3;
  dDouble=3.3 + nTmp / nn; // Сначала вычисляется ( nTmp / nn ), равное 33, цифры после запятой убираются
  //  3.3 + 33 = 36.3, результат с типом double. 

  //Получите результат без потери точности с помощью оператора явного
  //приведения типа
//  double dDouble3=...    // (4)
  double dDouble3 = static_cast<double>(nTmp) / nn + 3.3;

  return 0;
}